// Code generated by Prisma (prisma@1.25.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  commentReview: (where?: CommentReviewWhereInput) => Promise<boolean>;
  playlist: (where?: PlaylistWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
  view: (where?: ViewWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  commentReview: (where: CommentReviewWhereUniqueInput) => CommentReviewPromise;
  commentReviews: (args?: {
    where?: CommentReviewWhereInput;
    orderBy?: CommentReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CommentReview>;
  commentReviewsConnection: (args?: {
    where?: CommentReviewWhereInput;
    orderBy?: CommentReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentReviewConnectionPromise;
  playlist: (where: PlaylistWhereUniqueInput) => PlaylistPromise;
  playlists: (args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Playlist>;
  playlistsConnection: (args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaylistConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewPromise;
  reviews: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Review>;
  reviewsConnection: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  video: (where: VideoWhereUniqueInput) => VideoPromise;
  videos: (args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Video>;
  videosConnection: (args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoConnectionPromise;
  view: (where: ViewWhereUniqueInput) => ViewPromise;
  views: (args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<View>;
  viewsConnection: (args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ViewConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCommentReview: (data: CommentReviewCreateInput) => CommentReviewPromise;
  updateCommentReview: (args: {
    data: CommentReviewUpdateInput;
    where: CommentReviewWhereUniqueInput;
  }) => CommentReviewPromise;
  updateManyCommentReviews: (args: {
    data: CommentReviewUpdateManyMutationInput;
    where?: CommentReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertCommentReview: (args: {
    where: CommentReviewWhereUniqueInput;
    create: CommentReviewCreateInput;
    update: CommentReviewUpdateInput;
  }) => CommentReviewPromise;
  deleteCommentReview: (
    where: CommentReviewWhereUniqueInput
  ) => CommentReviewPromise;
  deleteManyCommentReviews: (
    where?: CommentReviewWhereInput
  ) => BatchPayloadPromise;
  createPlaylist: (data: PlaylistCreateInput) => PlaylistPromise;
  updatePlaylist: (args: {
    data: PlaylistUpdateInput;
    where: PlaylistWhereUniqueInput;
  }) => PlaylistPromise;
  updateManyPlaylists: (args: {
    data: PlaylistUpdateManyMutationInput;
    where?: PlaylistWhereInput;
  }) => BatchPayloadPromise;
  upsertPlaylist: (args: {
    where: PlaylistWhereUniqueInput;
    create: PlaylistCreateInput;
    update: PlaylistUpdateInput;
  }) => PlaylistPromise;
  deletePlaylist: (where: PlaylistWhereUniqueInput) => PlaylistPromise;
  deleteManyPlaylists: (where?: PlaylistWhereInput) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (args: {
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
  }) => ReviewPromise;
  updateManyReviews: (args: {
    data: ReviewUpdateManyMutationInput;
    where?: ReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertReview: (args: {
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
  }) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideo: (data: VideoCreateInput) => VideoPromise;
  updateVideo: (args: {
    data: VideoUpdateInput;
    where: VideoWhereUniqueInput;
  }) => VideoPromise;
  updateManyVideos: (args: {
    data: VideoUpdateManyMutationInput;
    where?: VideoWhereInput;
  }) => BatchPayloadPromise;
  upsertVideo: (args: {
    where: VideoWhereUniqueInput;
    create: VideoCreateInput;
    update: VideoUpdateInput;
  }) => VideoPromise;
  deleteVideo: (where: VideoWhereUniqueInput) => VideoPromise;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayloadPromise;
  createView: (data: ViewCreateInput) => ViewPromise;
  updateView: (args: {
    data: ViewUpdateInput;
    where: ViewWhereUniqueInput;
  }) => ViewPromise;
  updateManyViews: (args: {
    data: ViewUpdateManyMutationInput;
    where?: ViewWhereInput;
  }) => BatchPayloadPromise;
  upsertView: (args: {
    where: ViewWhereUniqueInput;
    create: ViewCreateInput;
    update: ViewUpdateInput;
  }) => ViewPromise;
  deleteView: (where: ViewWhereUniqueInput) => ViewPromise;
  deleteManyViews: (where?: ViewWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  commentReview: (
    where?: CommentReviewSubscriptionWhereInput
  ) => CommentReviewSubscriptionPayloadSubscription;
  playlist: (
    where?: PlaylistSubscriptionWhereInput
  ) => PlaylistSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
  view: (
    where?: ViewSubscriptionWhereInput
  ) => ViewSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Category =
  | "FILM_ANIMATION"
  | "AUTOS_VEHICLES"
  | "MUSIC"
  | "PETS_ANIMALS"
  | "SPORTS"
  | "TRAVEL_EVENTS"
  | "GAMING"
  | "PEOPLE_BLOGS"
  | "COMEDY"
  | "ENTERTAINMENT"
  | "NEWS_POLITICS"
  | "HOWTO_STYLE"
  | "EDUCATION"
  | "SCIENCE_TECHNOLOGY"
  | "NONPROFITS_ACTIVISM";

export type Role = "USER" | "ADMIN";

export type ReviewStatus = "LIKE" | "DISLIKE" | "NONE";

export type ViewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "complete_ASC"
  | "complete_DESC"
  | "progress_ASC"
  | "progress_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "videoURL_ASC"
  | "videoURL_DESC"
  | "thumbURL_ASC"
  | "thumbURL_DESC"
  | "posterURL_ASC"
  | "posterURL_DESC"
  | "previewURL_ASC"
  | "previewURL_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "isPublic_ASC"
  | "isPublic_DESC"
  | "category_ASC"
  | "category_DESC"
  | "allowComments_ASC"
  | "allowComments_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlaylistOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "isPublic_ASC"
  | "isPublic_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "reply_ASC"
  | "reply_DESC"
  | "edited_ASC"
  | "edited_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "googleID_ASC"
  | "googleID_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "image_ASC"
  | "image_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "googlePhotoAT_ASC"
  | "googlePhotoAT_DESC"
  | "googlePhotoRT_ASC"
  | "googlePhotoRT_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface PlaylistUpdateWithWhereUniqueWithoutUserInput {
  where: PlaylistWhereUniqueInput;
  data: PlaylistUpdateWithoutUserDataInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentUpdateWithWhereUniqueWithoutVideoInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutVideoDataInput;
}

export interface PlaylistWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  isPublic?: Boolean;
  isPublic_not?: Boolean;
  user?: UserWhereInput;
  videos_every?: VideoWhereInput;
  videos_some?: VideoWhereInput;
  videos_none?: VideoWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: PlaylistWhereInput[] | PlaylistWhereInput;
  OR?: PlaylistWhereInput[] | PlaylistWhereInput;
  NOT?: PlaylistWhereInput[] | PlaylistWhereInput;
}

export interface CommentUpdateWithoutVideoDataInput {
  text?: String;
  reply?: Boolean;
  replyTo?: CommentUpdateOneWithoutRepliesInput;
  edited?: Boolean;
  user?: UserUpdateOneWithoutCommentsInput;
  replies?: CommentUpdateManyWithoutReplyToInput;
  reviews?: CommentReviewUpdateManyWithoutCommentInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  reply?: Boolean;
  reply_not?: Boolean;
  replyTo?: CommentWhereInput;
  edited?: Boolean;
  edited_not?: Boolean;
  video?: VideoWhereInput;
  user?: UserWhereInput;
  replies_every?: CommentWhereInput;
  replies_some?: CommentWhereInput;
  replies_none?: CommentWhereInput;
  reviews_every?: CommentReviewWhereInput;
  reviews_some?: CommentReviewWhereInput;
  reviews_none?: CommentReviewWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface UserUpdateOneWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  update?: UserUpdateWithoutCommentsDataInput;
  upsert?: UserUpsertWithoutCommentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  googleID?: String;
  googleID_not?: String;
  googleID_in?: String[] | String;
  googleID_not_in?: String[] | String;
  googleID_lt?: String;
  googleID_lte?: String;
  googleID_gt?: String;
  googleID_gte?: String;
  googleID_contains?: String;
  googleID_not_contains?: String;
  googleID_starts_with?: String;
  googleID_not_starts_with?: String;
  googleID_ends_with?: String;
  googleID_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  verified?: Boolean;
  verified_not?: Boolean;
  googlePhotoAT?: String;
  googlePhotoAT_not?: String;
  googlePhotoAT_in?: String[] | String;
  googlePhotoAT_not_in?: String[] | String;
  googlePhotoAT_lt?: String;
  googlePhotoAT_lte?: String;
  googlePhotoAT_gt?: String;
  googlePhotoAT_gte?: String;
  googlePhotoAT_contains?: String;
  googlePhotoAT_not_contains?: String;
  googlePhotoAT_starts_with?: String;
  googlePhotoAT_not_starts_with?: String;
  googlePhotoAT_ends_with?: String;
  googlePhotoAT_not_ends_with?: String;
  googlePhotoRT?: String;
  googlePhotoRT_not?: String;
  googlePhotoRT_in?: String[] | String;
  googlePhotoRT_not_in?: String[] | String;
  googlePhotoRT_lt?: String;
  googlePhotoRT_lte?: String;
  googlePhotoRT_gt?: String;
  googlePhotoRT_gte?: String;
  googlePhotoRT_contains?: String;
  googlePhotoRT_not_contains?: String;
  googlePhotoRT_starts_with?: String;
  googlePhotoRT_not_starts_with?: String;
  googlePhotoRT_ends_with?: String;
  googlePhotoRT_not_ends_with?: String;
  videos_every?: VideoWhereInput;
  videos_some?: VideoWhereInput;
  videos_none?: VideoWhereInput;
  playlists_every?: PlaylistWhereInput;
  playlists_some?: PlaylistWhereInput;
  playlists_none?: PlaylistWhereInput;
  views_every?: ViewWhereInput;
  views_some?: ViewWhereInput;
  views_none?: ViewWhereInput;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  commentReviews_every?: CommentReviewWhereInput;
  commentReviews_some?: CommentReviewWhereInput;
  commentReviews_none?: CommentReviewWhereInput;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface VideoUpdatetagsInput {
  set?: String[] | String;
}

export interface ViewUpsertWithWhereUniqueWithoutVideoInput {
  where: ViewWhereUniqueInput;
  update: ViewUpdateWithoutVideoDataInput;
  create: ViewCreateWithoutVideoInput;
}

export interface ViewUpdateManyWithoutVideoInput {
  create?: ViewCreateWithoutVideoInput[] | ViewCreateWithoutVideoInput;
  delete?: ViewWhereUniqueInput[] | ViewWhereUniqueInput;
  connect?: ViewWhereUniqueInput[] | ViewWhereUniqueInput;
  disconnect?: ViewWhereUniqueInput[] | ViewWhereUniqueInput;
  update?:
    | ViewUpdateWithWhereUniqueWithoutVideoInput[]
    | ViewUpdateWithWhereUniqueWithoutVideoInput;
  upsert?:
    | ViewUpsertWithWhereUniqueWithoutVideoInput[]
    | ViewUpsertWithWhereUniqueWithoutVideoInput;
  deleteMany?: ViewScalarWhereInput[] | ViewScalarWhereInput;
  updateMany?:
    | ViewUpdateManyWithWhereNestedInput[]
    | ViewUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithoutCommentsDataInput {
  googleID?: String;
  email?: String;
  name?: String;
  image?: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoUpdateManyWithoutUserInput;
  playlists?: PlaylistUpdateManyWithoutUserInput;
  views?: ViewUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
  commentReviews?: CommentReviewUpdateManyWithoutUserInput;
  role?: Role;
}

export interface ViewUpdateWithWhereUniqueWithoutVideoInput {
  where: ViewWhereUniqueInput;
  data: ViewUpdateWithoutVideoDataInput;
}

export interface ViewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  complete?: Boolean;
  complete_not?: Boolean;
  progress?: Int;
  progress_not?: Int;
  progress_in?: Int[] | Int;
  progress_not_in?: Int[] | Int;
  progress_lt?: Int;
  progress_lte?: Int;
  progress_gt?: Int;
  progress_gte?: Int;
  video?: VideoWhereInput;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ViewWhereInput[] | ViewWhereInput;
  OR?: ViewWhereInput[] | ViewWhereInput;
  NOT?: ViewWhereInput[] | ViewWhereInput;
}

export interface ViewUpdateWithoutVideoDataInput {
  complete?: Boolean;
  progress?: Int;
  user?: UserUpdateOneWithoutViewsInput;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoWhereInput;
  AND?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  OR?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  NOT?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
}

export interface UserUpdateOneWithoutViewsInput {
  create?: UserCreateWithoutViewsInput;
  update?: UserUpdateWithoutViewsDataInput;
  upsert?: UserUpsertWithoutViewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReviewWhereInput;
  AND?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  OR?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  NOT?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
}

export interface UserUpdateWithoutViewsDataInput {
  googleID?: String;
  email?: String;
  name?: String;
  image?: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoUpdateManyWithoutUserInput;
  playlists?: PlaylistUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
  comments?: CommentUpdateManyWithoutUserInput;
  commentReviews?: CommentReviewUpdateManyWithoutUserInput;
  role?: Role;
}

export interface CommentReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentReviewWhereInput;
  AND?:
    | CommentReviewSubscriptionWhereInput[]
    | CommentReviewSubscriptionWhereInput;
  OR?:
    | CommentReviewSubscriptionWhereInput[]
    | CommentReviewSubscriptionWhereInput;
  NOT?:
    | CommentReviewSubscriptionWhereInput[]
    | CommentReviewSubscriptionWhereInput;
}

export interface VideoUpdateManyWithoutUserInput {
  create?: VideoCreateWithoutUserInput[] | VideoCreateWithoutUserInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutUserInput[]
    | VideoUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutUserInput[]
    | VideoUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface ViewUpdateManyMutationInput {
  complete?: Boolean;
  progress?: Int;
}

export interface VideoUpdateWithWhereUniqueWithoutUserInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutUserDataInput;
}

export interface ViewCreateInput {
  complete?: Boolean;
  progress?: Int;
  video?: VideoCreateOneWithoutViewsInput;
  user?: UserCreateOneWithoutViewsInput;
}

export interface VideoUpdateWithoutUserDataInput {
  videoURL?: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title?: String;
  description?: String;
  tags?: VideoUpdatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewUpdateManyWithoutVideoInput;
  reviews?: ReviewUpdateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentUpdateManyWithoutVideoInput;
}

export interface VideoUpdateManyMutationInput {
  videoURL?: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title?: String;
  description?: String;
  tags?: VideoUpdatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  allowComments?: Boolean;
}

export interface ReviewUpdateManyWithoutVideoInput {
  create?: ReviewCreateWithoutVideoInput[] | ReviewCreateWithoutVideoInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutVideoInput[]
    | ReviewUpdateWithWhereUniqueWithoutVideoInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutVideoInput[]
    | ReviewUpsertWithWhereUniqueWithoutVideoInput;
  deleteMany?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  updateMany?:
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput;
}

export interface UserUpdateManyMutationInput {
  googleID?: String;
  email?: String;
  name?: String;
  image?: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  role?: Role;
}

export interface ReviewUpdateWithWhereUniqueWithoutVideoInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutVideoDataInput;
}

export interface UserUpdateInput {
  googleID?: String;
  email?: String;
  name?: String;
  image?: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoUpdateManyWithoutUserInput;
  playlists?: PlaylistUpdateManyWithoutUserInput;
  views?: ViewUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
  comments?: CommentUpdateManyWithoutUserInput;
  commentReviews?: CommentReviewUpdateManyWithoutUserInput;
  role?: Role;
}

export interface ReviewUpdateWithoutVideoDataInput {
  status?: ReviewStatus;
  user?: UserUpdateOneWithoutReviewsInput;
}

export interface ReviewUpdateManyMutationInput {
  status?: ReviewStatus;
}

export interface UserUpdateOneWithoutReviewsInput {
  create?: UserCreateWithoutReviewsInput;
  update?: UserUpdateWithoutReviewsDataInput;
  upsert?: UserUpsertWithoutReviewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface ReviewUpdateInput {
  status?: ReviewStatus;
  video?: VideoUpdateOneWithoutReviewsInput;
  user?: UserUpdateOneWithoutReviewsInput;
}

export interface UserUpdateWithoutReviewsDataInput {
  googleID?: String;
  email?: String;
  name?: String;
  image?: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoUpdateManyWithoutUserInput;
  playlists?: PlaylistUpdateManyWithoutUserInput;
  views?: ViewUpdateManyWithoutUserInput;
  comments?: CommentUpdateManyWithoutUserInput;
  commentReviews?: CommentReviewUpdateManyWithoutUserInput;
  role?: Role;
}

export interface PlaylistUpdateManyMutationInput {
  name?: String;
  description?: String;
  isPublic?: Boolean;
}

export interface PlaylistUpdateManyWithoutUserInput {
  create?: PlaylistCreateWithoutUserInput[] | PlaylistCreateWithoutUserInput;
  delete?: PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput;
  connect?: PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput;
  disconnect?: PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput;
  update?:
    | PlaylistUpdateWithWhereUniqueWithoutUserInput[]
    | PlaylistUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PlaylistUpsertWithWhereUniqueWithoutUserInput[]
    | PlaylistUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
  updateMany?:
    | PlaylistUpdateManyWithWhereNestedInput[]
    | PlaylistUpdateManyWithWhereNestedInput;
}

export interface UserUpsertWithoutPlaylistsInput {
  update: UserUpdateWithoutPlaylistsDataInput;
  create: UserCreateWithoutPlaylistsInput;
}

export interface CommentUpdateManyMutationInput {
  text?: String;
  reply?: Boolean;
  edited?: Boolean;
}

export interface UserUpdateOneWithoutPlaylistsInput {
  create?: UserCreateWithoutPlaylistsInput;
  update?: UserUpdateWithoutPlaylistsDataInput;
  upsert?: UserUpsertWithoutPlaylistsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PlaylistUpdateWithoutUserDataInput {
  name?: String;
  description?: String;
  isPublic?: Boolean;
  videos?: VideoUpdateManyInput;
}

export type VideoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VideoUpdateManyInput {
  create?: VideoCreateInput[] | VideoCreateInput;
  update?:
    | VideoUpdateWithWhereUniqueNestedInput[]
    | VideoUpdateWithWhereUniqueNestedInput;
  upsert?:
    | VideoUpsertWithWhereUniqueNestedInput[]
    | VideoUpsertWithWhereUniqueNestedInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface UserCreateOneWithoutPlaylistsInput {
  create?: UserCreateWithoutPlaylistsInput;
  connect?: UserWhereUniqueInput;
}

export interface VideoUpdateWithWhereUniqueNestedInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateDataInput;
}

export type ViewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VideoUpdateDataInput {
  videoURL?: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title?: String;
  description?: String;
  tags?: VideoUpdatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewUpdateManyWithoutVideoInput;
  reviews?: ReviewUpdateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentUpdateManyWithoutVideoInput;
  user?: UserUpdateOneWithoutVideosInput;
}

export interface CommentReviewUpdateInput {
  status?: ReviewStatus;
  comment?: CommentUpdateOneWithoutReviewsInput;
  user?: UserUpdateOneWithoutCommentReviewsInput;
}

export interface CommentUpdateManyWithoutVideoInput {
  create?: CommentCreateWithoutVideoInput[] | CommentCreateWithoutVideoInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutVideoInput[]
    | CommentUpdateWithWhereUniqueWithoutVideoInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutVideoInput[]
    | CommentUpsertWithWhereUniqueWithoutVideoInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentCreateOneWithoutRepliesInput {
  create?: CommentCreateWithoutRepliesInput;
  connect?: CommentWhereUniqueInput;
}

export interface CommentUpsertWithoutRepliesInput {
  update: CommentUpdateWithoutRepliesDataInput;
  create: CommentCreateWithoutRepliesInput;
}

export interface VideoCreateOneWithoutCommentsInput {
  create?: VideoCreateWithoutCommentsInput;
  connect?: VideoWhereUniqueInput;
}

export interface CommentReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: ReviewStatus;
  status_not?: ReviewStatus;
  status_in?: ReviewStatus[] | ReviewStatus;
  status_not_in?: ReviewStatus[] | ReviewStatus;
  comment?: CommentWhereInput;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: CommentReviewWhereInput[] | CommentReviewWhereInput;
  OR?: CommentReviewWhereInput[] | CommentReviewWhereInput;
  NOT?: CommentReviewWhereInput[] | CommentReviewWhereInput;
}

export interface VideoCreatetagsInput {
  set?: String[] | String;
}

export interface ReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: ReviewStatus;
  status_not?: ReviewStatus;
  status_in?: ReviewStatus[] | ReviewStatus;
  status_not_in?: ReviewStatus[] | ReviewStatus;
  video?: VideoWhereInput;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ReviewWhereInput[] | ReviewWhereInput;
  OR?: ReviewWhereInput[] | ReviewWhereInput;
  NOT?: ReviewWhereInput[] | ReviewWhereInput;
}

export interface ViewCreateWithoutVideoInput {
  complete?: Boolean;
  progress?: Int;
  user?: UserCreateOneWithoutViewsInput;
}

export interface VideoUpsertWithoutCommentsInput {
  update: VideoUpdateWithoutCommentsDataInput;
  create: VideoCreateWithoutCommentsInput;
}

export interface UserCreateWithoutViewsInput {
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoCreateManyWithoutUserInput;
  playlists?: PlaylistCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
  comments?: CommentCreateManyWithoutUserInput;
  commentReviews?: CommentReviewCreateManyWithoutUserInput;
  role: Role;
}

export interface ViewUpdateManyWithoutUserInput {
  create?: ViewCreateWithoutUserInput[] | ViewCreateWithoutUserInput;
  delete?: ViewWhereUniqueInput[] | ViewWhereUniqueInput;
  connect?: ViewWhereUniqueInput[] | ViewWhereUniqueInput;
  disconnect?: ViewWhereUniqueInput[] | ViewWhereUniqueInput;
  update?:
    | ViewUpdateWithWhereUniqueWithoutUserInput[]
    | ViewUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ViewUpsertWithWhereUniqueWithoutUserInput[]
    | ViewUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ViewScalarWhereInput[] | ViewScalarWhereInput;
  updateMany?:
    | ViewUpdateManyWithWhereNestedInput[]
    | ViewUpdateManyWithWhereNestedInput;
}

export interface VideoCreateWithoutUserInput {
  videoURL: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title: String;
  description?: String;
  tags?: VideoCreatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewCreateManyWithoutVideoInput;
  reviews?: ReviewCreateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentCreateManyWithoutVideoInput;
}

export interface ViewUpdateWithWhereUniqueWithoutUserInput {
  where: ViewWhereUniqueInput;
  data: ViewUpdateWithoutUserDataInput;
}

export interface ReviewCreateWithoutVideoInput {
  status?: ReviewStatus;
  user?: UserCreateOneWithoutReviewsInput;
}

export interface ViewUpdateWithoutUserDataInput {
  complete?: Boolean;
  progress?: Int;
  video?: VideoUpdateOneWithoutViewsInput;
}

export interface UserCreateWithoutReviewsInput {
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoCreateManyWithoutUserInput;
  playlists?: PlaylistCreateManyWithoutUserInput;
  views?: ViewCreateManyWithoutUserInput;
  comments?: CommentCreateManyWithoutUserInput;
  commentReviews?: CommentReviewCreateManyWithoutUserInput;
  role: Role;
}

export interface VideoUpdateOneWithoutViewsInput {
  create?: VideoCreateWithoutViewsInput;
  update?: VideoUpdateWithoutViewsDataInput;
  upsert?: VideoUpsertWithoutViewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VideoWhereUniqueInput;
}

export interface PlaylistCreateWithoutUserInput {
  name: String;
  description?: String;
  isPublic?: Boolean;
  videos?: VideoCreateManyInput;
}

export interface VideoUpdateWithoutViewsDataInput {
  videoURL?: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title?: String;
  description?: String;
  tags?: VideoUpdatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  reviews?: ReviewUpdateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentUpdateManyWithoutVideoInput;
  user?: UserUpdateOneWithoutVideosInput;
}

export interface VideoCreateInput {
  videoURL: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title: String;
  description?: String;
  tags?: VideoCreatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewCreateManyWithoutVideoInput;
  reviews?: ReviewCreateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentCreateManyWithoutVideoInput;
  user?: UserCreateOneWithoutVideosInput;
}

export interface UserUpdateOneWithoutVideosInput {
  create?: UserCreateWithoutVideosInput;
  update?: UserUpdateWithoutVideosDataInput;
  upsert?: UserUpsertWithoutVideosInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface CommentCreateWithoutVideoInput {
  text: String;
  reply: Boolean;
  replyTo?: CommentCreateOneWithoutRepliesInput;
  edited?: Boolean;
  user?: UserCreateOneWithoutCommentsInput;
  replies?: CommentCreateManyWithoutReplyToInput;
  reviews?: CommentReviewCreateManyWithoutCommentInput;
}

export interface UserUpdateWithoutVideosDataInput {
  googleID?: String;
  email?: String;
  name?: String;
  image?: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  playlists?: PlaylistUpdateManyWithoutUserInput;
  views?: ViewUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
  comments?: CommentUpdateManyWithoutUserInput;
  commentReviews?: CommentReviewUpdateManyWithoutUserInput;
  role?: Role;
}

export interface UserCreateWithoutCommentsInput {
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoCreateManyWithoutUserInput;
  playlists?: PlaylistCreateManyWithoutUserInput;
  views?: ViewCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
  commentReviews?: CommentReviewCreateManyWithoutUserInput;
  role: Role;
}

export interface ReviewUpdateManyWithoutUserInput {
  create?: ReviewCreateWithoutUserInput[] | ReviewCreateWithoutUserInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    | ReviewUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    | ReviewUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  updateMany?:
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput;
}

export interface ViewCreateWithoutUserInput {
  complete?: Boolean;
  progress?: Int;
  video?: VideoCreateOneWithoutViewsInput;
}

export interface ReviewUpdateWithWhereUniqueWithoutUserInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutUserDataInput;
}

export interface VideoCreateWithoutViewsInput {
  videoURL: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title: String;
  description?: String;
  tags?: VideoCreatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  reviews?: ReviewCreateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentCreateManyWithoutVideoInput;
  user?: UserCreateOneWithoutVideosInput;
}

export interface ReviewUpdateWithoutUserDataInput {
  status?: ReviewStatus;
  video?: VideoUpdateOneWithoutReviewsInput;
}

export interface UserCreateWithoutVideosInput {
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  playlists?: PlaylistCreateManyWithoutUserInput;
  views?: ViewCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
  comments?: CommentCreateManyWithoutUserInput;
  commentReviews?: CommentReviewCreateManyWithoutUserInput;
  role: Role;
}

export interface VideoUpdateOneWithoutReviewsInput {
  create?: VideoCreateWithoutReviewsInput;
  update?: VideoUpdateWithoutReviewsDataInput;
  upsert?: VideoUpsertWithoutReviewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VideoWhereUniqueInput;
}

export interface ReviewCreateWithoutUserInput {
  status?: ReviewStatus;
  video?: VideoCreateOneWithoutReviewsInput;
}

export interface VideoUpdateWithoutReviewsDataInput {
  videoURL?: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title?: String;
  description?: String;
  tags?: VideoUpdatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewUpdateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentUpdateManyWithoutVideoInput;
  user?: UserUpdateOneWithoutVideosInput;
}

export interface VideoCreateWithoutReviewsInput {
  videoURL: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title: String;
  description?: String;
  tags?: VideoCreatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewCreateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentCreateManyWithoutVideoInput;
  user?: UserCreateOneWithoutVideosInput;
}

export interface VideoUpsertWithoutReviewsInput {
  update: VideoUpdateWithoutReviewsDataInput;
  create: VideoCreateWithoutReviewsInput;
}

export interface CommentCreateWithoutUserInput {
  text: String;
  reply: Boolean;
  replyTo?: CommentCreateOneWithoutRepliesInput;
  edited?: Boolean;
  video?: VideoCreateOneWithoutCommentsInput;
  replies?: CommentCreateManyWithoutReplyToInput;
  reviews?: CommentReviewCreateManyWithoutCommentInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutUserInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutUserDataInput;
  create: ReviewCreateWithoutUserInput;
}

export interface CommentCreateWithoutReplyToInput {
  text: String;
  reply: Boolean;
  edited?: Boolean;
  video?: VideoCreateOneWithoutCommentsInput;
  user?: UserCreateOneWithoutCommentsInput;
  replies?: CommentCreateManyWithoutReplyToInput;
  reviews?: CommentReviewCreateManyWithoutCommentInput;
}

export interface ReviewScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: ReviewStatus;
  status_not?: ReviewStatus;
  status_in?: ReviewStatus[] | ReviewStatus;
  status_not_in?: ReviewStatus[] | ReviewStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  OR?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  NOT?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
}

export interface CommentReviewCreateWithoutCommentInput {
  status?: ReviewStatus;
  user?: UserCreateOneWithoutCommentReviewsInput;
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput;
  data: ReviewUpdateManyDataInput;
}

export interface UserCreateWithoutCommentReviewsInput {
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoCreateManyWithoutUserInput;
  playlists?: PlaylistCreateManyWithoutUserInput;
  views?: ViewCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
  comments?: CommentCreateManyWithoutUserInput;
  role: Role;
}

export interface ReviewUpdateManyDataInput {
  status?: ReviewStatus;
}

export interface CommentReviewCreateWithoutUserInput {
  status?: ReviewStatus;
  comment?: CommentCreateOneWithoutReviewsInput;
}

export interface CommentUpdateManyWithoutUserInput {
  create?: CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutUserInput[]
    | CommentUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutUserInput[]
    | CommentUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentCreateWithoutReviewsInput {
  text: String;
  reply: Boolean;
  replyTo?: CommentCreateOneWithoutRepliesInput;
  edited?: Boolean;
  video?: VideoCreateOneWithoutCommentsInput;
  user?: UserCreateOneWithoutCommentsInput;
  replies?: CommentCreateManyWithoutReplyToInput;
}

export interface CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutUserDataInput;
}

export interface CommentUpdateOneWithoutRepliesInput {
  create?: CommentCreateWithoutRepliesInput;
  update?: CommentUpdateWithoutRepliesDataInput;
  upsert?: CommentUpsertWithoutRepliesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CommentWhereUniqueInput;
}

export interface CommentUpdateWithoutUserDataInput {
  text?: String;
  reply?: Boolean;
  replyTo?: CommentUpdateOneWithoutRepliesInput;
  edited?: Boolean;
  video?: VideoUpdateOneWithoutCommentsInput;
  replies?: CommentUpdateManyWithoutReplyToInput;
  reviews?: CommentReviewUpdateManyWithoutCommentInput;
}

export interface VideoUpdateOneWithoutCommentsInput {
  create?: VideoCreateWithoutCommentsInput;
  update?: VideoUpdateWithoutCommentsDataInput;
  upsert?: VideoUpsertWithoutCommentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VideoWhereUniqueInput;
}

export interface CommentUpdateManyWithoutReplyToInput {
  create?:
    | CommentCreateWithoutReplyToInput[]
    | CommentCreateWithoutReplyToInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutReplyToInput[]
    | CommentUpdateWithWhereUniqueWithoutReplyToInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutReplyToInput[]
    | CommentUpsertWithWhereUniqueWithoutReplyToInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface VideoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  videoURL?: String;
  videoURL_not?: String;
  videoURL_in?: String[] | String;
  videoURL_not_in?: String[] | String;
  videoURL_lt?: String;
  videoURL_lte?: String;
  videoURL_gt?: String;
  videoURL_gte?: String;
  videoURL_contains?: String;
  videoURL_not_contains?: String;
  videoURL_starts_with?: String;
  videoURL_not_starts_with?: String;
  videoURL_ends_with?: String;
  videoURL_not_ends_with?: String;
  thumbURL?: String;
  thumbURL_not?: String;
  thumbURL_in?: String[] | String;
  thumbURL_not_in?: String[] | String;
  thumbURL_lt?: String;
  thumbURL_lte?: String;
  thumbURL_gt?: String;
  thumbURL_gte?: String;
  thumbURL_contains?: String;
  thumbURL_not_contains?: String;
  thumbURL_starts_with?: String;
  thumbURL_not_starts_with?: String;
  thumbURL_ends_with?: String;
  thumbURL_not_ends_with?: String;
  posterURL?: String;
  posterURL_not?: String;
  posterURL_in?: String[] | String;
  posterURL_not_in?: String[] | String;
  posterURL_lt?: String;
  posterURL_lte?: String;
  posterURL_gt?: String;
  posterURL_gte?: String;
  posterURL_contains?: String;
  posterURL_not_contains?: String;
  posterURL_starts_with?: String;
  posterURL_not_starts_with?: String;
  posterURL_ends_with?: String;
  posterURL_not_ends_with?: String;
  previewURL?: String;
  previewURL_not?: String;
  previewURL_in?: String[] | String;
  previewURL_not_in?: String[] | String;
  previewURL_lt?: String;
  previewURL_lte?: String;
  previewURL_gt?: String;
  previewURL_gte?: String;
  previewURL_contains?: String;
  previewURL_not_contains?: String;
  previewURL_starts_with?: String;
  previewURL_not_starts_with?: String;
  previewURL_ends_with?: String;
  previewURL_not_ends_with?: String;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  isPublic?: Boolean;
  isPublic_not?: Boolean;
  category?: Category;
  category_not?: Category;
  category_in?: Category[] | Category;
  category_not_in?: Category[] | Category;
  views_every?: ViewWhereInput;
  views_some?: ViewWhereInput;
  views_none?: ViewWhereInput;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  allowComments?: Boolean;
  allowComments_not?: Boolean;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: VideoWhereInput[] | VideoWhereInput;
  OR?: VideoWhereInput[] | VideoWhereInput;
  NOT?: VideoWhereInput[] | VideoWhereInput;
}

export interface CommentUpdateWithWhereUniqueWithoutReplyToInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutReplyToDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CommentUpdateWithoutReplyToDataInput {
  text?: String;
  reply?: Boolean;
  edited?: Boolean;
  video?: VideoUpdateOneWithoutCommentsInput;
  user?: UserUpdateOneWithoutCommentsInput;
  replies?: CommentUpdateManyWithoutReplyToInput;
  reviews?: CommentReviewUpdateManyWithoutCommentInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface CommentReviewUpdateManyWithoutCommentInput {
  create?:
    | CommentReviewCreateWithoutCommentInput[]
    | CommentReviewCreateWithoutCommentInput;
  delete?: CommentReviewWhereUniqueInput[] | CommentReviewWhereUniqueInput;
  connect?: CommentReviewWhereUniqueInput[] | CommentReviewWhereUniqueInput;
  disconnect?: CommentReviewWhereUniqueInput[] | CommentReviewWhereUniqueInput;
  update?:
    | CommentReviewUpdateWithWhereUniqueWithoutCommentInput[]
    | CommentReviewUpdateWithWhereUniqueWithoutCommentInput;
  upsert?:
    | CommentReviewUpsertWithWhereUniqueWithoutCommentInput[]
    | CommentReviewUpsertWithWhereUniqueWithoutCommentInput;
  deleteMany?: CommentReviewScalarWhereInput[] | CommentReviewScalarWhereInput;
  updateMany?:
    | CommentReviewUpdateManyWithWhereNestedInput[]
    | CommentReviewUpdateManyWithWhereNestedInput;
}

export type CommentReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentReviewUpdateWithWhereUniqueWithoutCommentInput {
  where: CommentReviewWhereUniqueInput;
  data: CommentReviewUpdateWithoutCommentDataInput;
}

export type PlaylistWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentReviewUpdateWithoutCommentDataInput {
  status?: ReviewStatus;
  user?: UserUpdateOneWithoutCommentReviewsInput;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneWithoutCommentReviewsInput {
  create?: UserCreateWithoutCommentReviewsInput;
  update?: UserUpdateWithoutCommentReviewsDataInput;
  upsert?: UserUpsertWithoutCommentReviewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  googleID?: String;
  email?: String;
}>;

export interface UserUpdateWithoutCommentReviewsDataInput {
  googleID?: String;
  email?: String;
  name?: String;
  image?: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoUpdateManyWithoutUserInput;
  playlists?: PlaylistUpdateManyWithoutUserInput;
  views?: ViewUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
  comments?: CommentUpdateManyWithoutUserInput;
  role?: Role;
}

export interface PlaylistUpdateInput {
  name?: String;
  description?: String;
  isPublic?: Boolean;
  user?: UserUpdateOneWithoutPlaylistsInput;
  videos?: VideoUpdateManyInput;
}

export interface UserUpsertWithoutCommentReviewsInput {
  update: UserUpdateWithoutCommentReviewsDataInput;
  create: UserCreateWithoutCommentReviewsInput;
}

export interface PlaylistCreateInput {
  name: String;
  description?: String;
  isPublic?: Boolean;
  user?: UserCreateOneWithoutPlaylistsInput;
  videos?: VideoCreateManyInput;
}

export interface CommentReviewUpsertWithWhereUniqueWithoutCommentInput {
  where: CommentReviewWhereUniqueInput;
  update: CommentReviewUpdateWithoutCommentDataInput;
  create: CommentReviewCreateWithoutCommentInput;
}

export interface CommentReviewCreateInput {
  status?: ReviewStatus;
  comment?: CommentCreateOneWithoutReviewsInput;
  user?: UserCreateOneWithoutCommentReviewsInput;
}

export interface CommentReviewScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: ReviewStatus;
  status_not?: ReviewStatus;
  status_in?: ReviewStatus[] | ReviewStatus;
  status_not_in?: ReviewStatus[] | ReviewStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: CommentReviewScalarWhereInput[] | CommentReviewScalarWhereInput;
  OR?: CommentReviewScalarWhereInput[] | CommentReviewScalarWhereInput;
  NOT?: CommentReviewScalarWhereInput[] | CommentReviewScalarWhereInput;
}

export interface CommentCreateWithoutRepliesInput {
  text: String;
  reply: Boolean;
  replyTo?: CommentCreateOneWithoutRepliesInput;
  edited?: Boolean;
  video?: VideoCreateOneWithoutCommentsInput;
  user?: UserCreateOneWithoutCommentsInput;
  reviews?: CommentReviewCreateManyWithoutCommentInput;
}

export interface CommentReviewUpdateManyWithWhereNestedInput {
  where: CommentReviewScalarWhereInput;
  data: CommentReviewUpdateManyDataInput;
}

export interface ViewCreateManyWithoutVideoInput {
  create?: ViewCreateWithoutVideoInput[] | ViewCreateWithoutVideoInput;
  connect?: ViewWhereUniqueInput[] | ViewWhereUniqueInput;
}

export interface CommentReviewUpdateManyDataInput {
  status?: ReviewStatus;
}

export interface VideoCreateManyWithoutUserInput {
  create?: VideoCreateWithoutUserInput[] | VideoCreateWithoutUserInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface CommentUpsertWithWhereUniqueWithoutReplyToInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutReplyToDataInput;
  create: CommentCreateWithoutReplyToInput;
}

export interface UserCreateOneWithoutReviewsInput {
  create?: UserCreateWithoutReviewsInput;
  connect?: UserWhereUniqueInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  reply?: Boolean;
  reply_not?: Boolean;
  edited?: Boolean;
  edited_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface VideoCreateManyInput {
  create?: VideoCreateInput[] | VideoCreateInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface CommentUpdateManyDataInput {
  text?: String;
  reply?: Boolean;
  edited?: Boolean;
}

export interface VideoCreateOneWithoutViewsInput {
  create?: VideoCreateWithoutViewsInput;
  connect?: VideoWhereUniqueInput;
}

export interface CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutUserDataInput;
  create: CommentCreateWithoutUserInput;
}

export interface ReviewCreateManyWithoutUserInput {
  create?: ReviewCreateWithoutUserInput[] | ReviewCreateWithoutUserInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface CommentReviewUpdateManyWithoutUserInput {
  create?:
    | CommentReviewCreateWithoutUserInput[]
    | CommentReviewCreateWithoutUserInput;
  delete?: CommentReviewWhereUniqueInput[] | CommentReviewWhereUniqueInput;
  connect?: CommentReviewWhereUniqueInput[] | CommentReviewWhereUniqueInput;
  disconnect?: CommentReviewWhereUniqueInput[] | CommentReviewWhereUniqueInput;
  update?:
    | CommentReviewUpdateWithWhereUniqueWithoutUserInput[]
    | CommentReviewUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CommentReviewUpsertWithWhereUniqueWithoutUserInput[]
    | CommentReviewUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: CommentReviewScalarWhereInput[] | CommentReviewScalarWhereInput;
  updateMany?:
    | CommentReviewUpdateManyWithWhereNestedInput[]
    | CommentReviewUpdateManyWithWhereNestedInput;
}

export interface CommentCreateManyWithoutUserInput {
  create?: CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentReviewUpdateWithWhereUniqueWithoutUserInput {
  where: CommentReviewWhereUniqueInput;
  data: CommentReviewUpdateWithoutUserDataInput;
}

export interface CommentReviewCreateManyWithoutCommentInput {
  create?:
    | CommentReviewCreateWithoutCommentInput[]
    | CommentReviewCreateWithoutCommentInput;
  connect?: CommentReviewWhereUniqueInput[] | CommentReviewWhereUniqueInput;
}

export interface CommentReviewUpdateWithoutUserDataInput {
  status?: ReviewStatus;
  comment?: CommentUpdateOneWithoutReviewsInput;
}

export interface CommentReviewCreateManyWithoutUserInput {
  create?:
    | CommentReviewCreateWithoutUserInput[]
    | CommentReviewCreateWithoutUserInput;
  connect?: CommentReviewWhereUniqueInput[] | CommentReviewWhereUniqueInput;
}

export interface CommentUpdateOneWithoutReviewsInput {
  create?: CommentCreateWithoutReviewsInput;
  update?: CommentUpdateWithoutReviewsDataInput;
  upsert?: CommentUpsertWithoutReviewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CommentWhereUniqueInput;
}

export interface CommentUpdateInput {
  text?: String;
  reply?: Boolean;
  replyTo?: CommentUpdateOneWithoutRepliesInput;
  edited?: Boolean;
  video?: VideoUpdateOneWithoutCommentsInput;
  user?: UserUpdateOneWithoutCommentsInput;
  replies?: CommentUpdateManyWithoutReplyToInput;
  reviews?: CommentReviewUpdateManyWithoutCommentInput;
}

export interface CommentUpdateWithoutReviewsDataInput {
  text?: String;
  reply?: Boolean;
  replyTo?: CommentUpdateOneWithoutRepliesInput;
  edited?: Boolean;
  video?: VideoUpdateOneWithoutCommentsInput;
  user?: UserUpdateOneWithoutCommentsInput;
  replies?: CommentUpdateManyWithoutReplyToInput;
}

export interface VideoUpdateWithoutCommentsDataInput {
  videoURL?: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title?: String;
  description?: String;
  tags?: VideoUpdatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewUpdateManyWithoutVideoInput;
  reviews?: ReviewUpdateManyWithoutVideoInput;
  allowComments?: Boolean;
  user?: UserUpdateOneWithoutVideosInput;
}

export interface CommentUpsertWithoutReviewsInput {
  update: CommentUpdateWithoutReviewsDataInput;
  create: CommentCreateWithoutReviewsInput;
}

export interface PlaylistSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlaylistWhereInput;
  AND?: PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput;
  OR?: PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput;
  NOT?: PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput;
}

export interface CommentReviewUpsertWithWhereUniqueWithoutUserInput {
  where: CommentReviewWhereUniqueInput;
  update: CommentReviewUpdateWithoutUserDataInput;
  create: CommentReviewCreateWithoutUserInput;
}

export interface VideoUpdateInput {
  videoURL?: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title?: String;
  description?: String;
  tags?: VideoUpdatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewUpdateManyWithoutVideoInput;
  reviews?: ReviewUpdateManyWithoutVideoInput;
  allowComments?: Boolean;
  comments?: CommentUpdateManyWithoutVideoInput;
  user?: UserUpdateOneWithoutVideosInput;
}

export interface UserUpsertWithoutVideosInput {
  update: UserUpdateWithoutVideosDataInput;
  create: UserCreateWithoutVideosInput;
}

export interface ReviewCreateInput {
  status?: ReviewStatus;
  video?: VideoCreateOneWithoutReviewsInput;
  user?: UserCreateOneWithoutReviewsInput;
}

export interface VideoUpsertWithoutViewsInput {
  update: VideoUpdateWithoutViewsDataInput;
  create: VideoCreateWithoutViewsInput;
}

export interface UserCreateWithoutPlaylistsInput {
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoCreateManyWithoutUserInput;
  views?: ViewCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
  comments?: CommentCreateManyWithoutUserInput;
  commentReviews?: CommentReviewCreateManyWithoutUserInput;
  role: Role;
}

export interface ViewUpsertWithWhereUniqueWithoutUserInput {
  where: ViewWhereUniqueInput;
  update: ViewUpdateWithoutUserDataInput;
  create: ViewCreateWithoutUserInput;
}

export interface CommentCreateInput {
  text: String;
  reply: Boolean;
  replyTo?: CommentCreateOneWithoutRepliesInput;
  edited?: Boolean;
  video?: VideoCreateOneWithoutCommentsInput;
  user?: UserCreateOneWithoutCommentsInput;
  replies?: CommentCreateManyWithoutReplyToInput;
  reviews?: CommentReviewCreateManyWithoutCommentInput;
}

export interface ViewScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  complete?: Boolean;
  complete_not?: Boolean;
  progress?: Int;
  progress_not?: Int;
  progress_in?: Int[] | Int;
  progress_not_in?: Int[] | Int;
  progress_lt?: Int;
  progress_lte?: Int;
  progress_gt?: Int;
  progress_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ViewScalarWhereInput[] | ViewScalarWhereInput;
  OR?: ViewScalarWhereInput[] | ViewScalarWhereInput;
  NOT?: ViewScalarWhereInput[] | ViewScalarWhereInput;
}

export interface UserCreateOneWithoutViewsInput {
  create?: UserCreateWithoutViewsInput;
  connect?: UserWhereUniqueInput;
}

export interface ViewUpdateManyWithWhereNestedInput {
  where: ViewScalarWhereInput;
  data: ViewUpdateManyDataInput;
}

export interface PlaylistCreateManyWithoutUserInput {
  create?: PlaylistCreateWithoutUserInput[] | PlaylistCreateWithoutUserInput;
  connect?: PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput;
}

export interface ViewUpdateManyDataInput {
  complete?: Boolean;
  progress?: Int;
}

export interface ViewCreateManyWithoutUserInput {
  create?: ViewCreateWithoutUserInput[] | ViewCreateWithoutUserInput;
  connect?: ViewWhereUniqueInput[] | ViewWhereUniqueInput;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface VideoCreateOneWithoutReviewsInput {
  create?: VideoCreateWithoutReviewsInput;
  connect?: VideoWhereUniqueInput;
}

export interface CommentUpsertWithWhereUniqueWithoutVideoInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutVideoDataInput;
  create: CommentCreateWithoutVideoInput;
}

export interface UserCreateOneWithoutCommentReviewsInput {
  create?: UserCreateWithoutCommentReviewsInput;
  connect?: UserWhereUniqueInput;
}

export interface VideoUpsertWithWhereUniqueNestedInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateDataInput;
  create: VideoCreateInput;
}

export interface CommentUpdateWithoutRepliesDataInput {
  text?: String;
  reply?: Boolean;
  replyTo?: CommentUpdateOneWithoutRepliesInput;
  edited?: Boolean;
  video?: VideoUpdateOneWithoutCommentsInput;
  user?: UserUpdateOneWithoutCommentsInput;
  reviews?: CommentReviewUpdateManyWithoutCommentInput;
}

export interface VideoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  videoURL?: String;
  videoURL_not?: String;
  videoURL_in?: String[] | String;
  videoURL_not_in?: String[] | String;
  videoURL_lt?: String;
  videoURL_lte?: String;
  videoURL_gt?: String;
  videoURL_gte?: String;
  videoURL_contains?: String;
  videoURL_not_contains?: String;
  videoURL_starts_with?: String;
  videoURL_not_starts_with?: String;
  videoURL_ends_with?: String;
  videoURL_not_ends_with?: String;
  thumbURL?: String;
  thumbURL_not?: String;
  thumbURL_in?: String[] | String;
  thumbURL_not_in?: String[] | String;
  thumbURL_lt?: String;
  thumbURL_lte?: String;
  thumbURL_gt?: String;
  thumbURL_gte?: String;
  thumbURL_contains?: String;
  thumbURL_not_contains?: String;
  thumbURL_starts_with?: String;
  thumbURL_not_starts_with?: String;
  thumbURL_ends_with?: String;
  thumbURL_not_ends_with?: String;
  posterURL?: String;
  posterURL_not?: String;
  posterURL_in?: String[] | String;
  posterURL_not_in?: String[] | String;
  posterURL_lt?: String;
  posterURL_lte?: String;
  posterURL_gt?: String;
  posterURL_gte?: String;
  posterURL_contains?: String;
  posterURL_not_contains?: String;
  posterURL_starts_with?: String;
  posterURL_not_starts_with?: String;
  posterURL_ends_with?: String;
  posterURL_not_ends_with?: String;
  previewURL?: String;
  previewURL_not?: String;
  previewURL_in?: String[] | String;
  previewURL_not_in?: String[] | String;
  previewURL_lt?: String;
  previewURL_lte?: String;
  previewURL_gt?: String;
  previewURL_gte?: String;
  previewURL_contains?: String;
  previewURL_not_contains?: String;
  previewURL_starts_with?: String;
  previewURL_not_starts_with?: String;
  previewURL_ends_with?: String;
  previewURL_not_ends_with?: String;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  isPublic?: Boolean;
  isPublic_not?: Boolean;
  category?: Category;
  category_not?: Category;
  category_in?: Category[] | Category;
  category_not_in?: Category[] | Category;
  allowComments?: Boolean;
  allowComments_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  OR?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  NOT?: VideoScalarWhereInput[] | VideoScalarWhereInput;
}

export interface ViewUpdateInput {
  complete?: Boolean;
  progress?: Int;
  video?: VideoUpdateOneWithoutViewsInput;
  user?: UserUpdateOneWithoutViewsInput;
}

export interface VideoUpdateManyWithWhereNestedInput {
  where: VideoScalarWhereInput;
  data: VideoUpdateManyDataInput;
}

export interface UserUpdateWithoutPlaylistsDataInput {
  googleID?: String;
  email?: String;
  name?: String;
  image?: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoUpdateManyWithoutUserInput;
  views?: ViewUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
  comments?: CommentUpdateManyWithoutUserInput;
  commentReviews?: CommentReviewUpdateManyWithoutUserInput;
  role?: Role;
}

export interface VideoUpdateManyDataInput {
  videoURL?: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title?: String;
  description?: String;
  tags?: VideoUpdatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  allowComments?: Boolean;
}

export interface VideoCreateWithoutCommentsInput {
  videoURL: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title: String;
  description?: String;
  tags?: VideoCreatetagsInput;
  isPublished?: Boolean;
  isPublic?: Boolean;
  category?: Category;
  views?: ViewCreateManyWithoutVideoInput;
  reviews?: ReviewCreateManyWithoutVideoInput;
  allowComments?: Boolean;
  user?: UserCreateOneWithoutVideosInput;
}

export interface PlaylistUpsertWithWhereUniqueWithoutUserInput {
  where: PlaylistWhereUniqueInput;
  update: PlaylistUpdateWithoutUserDataInput;
  create: PlaylistCreateWithoutUserInput;
}

export interface CommentCreateManyWithoutVideoInput {
  create?: CommentCreateWithoutVideoInput[] | CommentCreateWithoutVideoInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface PlaylistScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  isPublic?: Boolean;
  isPublic_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
  OR?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
  NOT?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
}

export interface CommentCreateManyWithoutReplyToInput {
  create?:
    | CommentCreateWithoutReplyToInput[]
    | CommentCreateWithoutReplyToInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface PlaylistUpdateManyWithWhereNestedInput {
  where: PlaylistScalarWhereInput;
  data: PlaylistUpdateManyDataInput;
}

export interface ViewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ViewWhereInput;
  AND?: ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput;
  OR?: ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput;
  NOT?: ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput;
}

export interface PlaylistUpdateManyDataInput {
  name?: String;
  description?: String;
  isPublic?: Boolean;
}

export interface CommentReviewUpdateManyMutationInput {
  status?: ReviewStatus;
}

export interface UserUpsertWithoutViewsInput {
  update: UserUpdateWithoutViewsDataInput;
  create: UserCreateWithoutViewsInput;
}

export interface VideoUpsertWithWhereUniqueWithoutUserInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutUserDataInput;
  create: VideoCreateWithoutUserInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutVideoInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutVideoDataInput;
  create: ReviewCreateWithoutVideoInput;
}

export interface UserUpsertWithoutReviewsInput {
  update: UserUpdateWithoutReviewsDataInput;
  create: UserCreateWithoutReviewsInput;
}

export interface ReviewCreateManyWithoutVideoInput {
  create?: ReviewCreateWithoutVideoInput[] | ReviewCreateWithoutVideoInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface UserCreateInput {
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  videos?: VideoCreateManyWithoutUserInput;
  playlists?: PlaylistCreateManyWithoutUserInput;
  views?: ViewCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
  comments?: CommentCreateManyWithoutUserInput;
  commentReviews?: CommentReviewCreateManyWithoutUserInput;
  role: Role;
}

export interface CommentCreateOneWithoutReviewsInput {
  create?: CommentCreateWithoutReviewsInput;
  connect?: CommentWhereUniqueInput;
}

export interface UserCreateOneWithoutVideosInput {
  create?: UserCreateWithoutVideosInput;
  connect?: UserWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ViewPreviousValues {
  id: ID_Output;
  complete?: Boolean;
  progress?: Int;
  createdAt: DateTimeOutput;
}

export interface ViewPreviousValuesPromise
  extends Promise<ViewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  complete: () => Promise<Boolean>;
  progress: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ViewPreviousValuesSubscription
  extends Promise<AsyncIterator<ViewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  complete: () => Promise<AsyncIterator<Boolean>>;
  progress: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface View {
  id: ID_Output;
  complete?: Boolean;
  progress?: Int;
  createdAt: DateTimeOutput;
}

export interface ViewPromise extends Promise<View>, Fragmentable {
  id: () => Promise<ID_Output>;
  complete: () => Promise<Boolean>;
  progress: () => Promise<Int>;
  video: <T = VideoPromise>() => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ViewSubscription
  extends Promise<AsyncIterator<View>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  complete: () => Promise<AsyncIterator<Boolean>>;
  progress: () => Promise<AsyncIterator<Int>>;
  video: <T = VideoSubscription>() => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  role: Role;
  createdAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  googleID: () => Promise<String>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  verified: () => Promise<Boolean>;
  googlePhotoAT: () => Promise<String>;
  googlePhotoRT: () => Promise<String>;
  videos: <T = FragmentableArray<Video>>(args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  playlists: <T = FragmentableArray<Playlist>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  views: <T = FragmentableArray<View>>(args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commentReviews: <T = FragmentableArray<CommentReview>>(args?: {
    where?: CommentReviewWhereInput;
    orderBy?: CommentReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<Role>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  googleID: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  googlePhotoAT: () => Promise<AsyncIterator<String>>;
  googlePhotoRT: () => Promise<AsyncIterator<String>>;
  videos: <T = Promise<AsyncIterator<VideoSubscription>>>(args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  playlists: <T = Promise<AsyncIterator<PlaylistSubscription>>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  views: <T = Promise<AsyncIterator<ViewSubscription>>>(args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commentReviews: <
    T = Promise<AsyncIterator<CommentReviewSubscription>>
  >(args?: {
    where?: CommentReviewWhereInput;
    orderBy?: CommentReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<AsyncIterator<Role>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Playlist {
  id: ID_Output;
  name: String;
  description?: String;
  isPublic?: Boolean;
  createdAt: DateTimeOutput;
}

export interface PlaylistPromise extends Promise<Playlist>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  isPublic: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  videos: <T = FragmentableArray<Video>>(args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistSubscription
  extends Promise<AsyncIterator<Playlist>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
  videos: <T = Promise<AsyncIterator<VideoSubscription>>>(args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VideoSubscriptionPayload {
  mutation: MutationType;
  node: Video;
  updatedFields: String[];
  previousValues: VideoPreviousValues;
}

export interface VideoSubscriptionPayloadPromise
  extends Promise<VideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValuesPromise>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateView {
  count: Int;
}

export interface AggregateViewPromise
  extends Promise<AggregateView>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateViewSubscription
  extends Promise<AsyncIterator<AggregateView>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ViewConnection {
  pageInfo: PageInfo;
  edges: ViewEdge[];
}

export interface ViewConnectionPromise
  extends Promise<ViewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ViewEdge>>() => T;
  aggregate: <T = AggregateViewPromise>() => T;
}

export interface ViewConnectionSubscription
  extends Promise<AsyncIterator<ViewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ViewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateViewSubscription>() => T;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface VideoEdge {
  node: Video;
  cursor: String;
}

export interface VideoEdgePromise extends Promise<VideoEdge>, Fragmentable {
  node: <T = VideoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdge>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Comment {
  id: ID_Output;
  text: String;
  reply: Boolean;
  edited?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  reply: () => Promise<Boolean>;
  replyTo: <T = CommentPromise>() => T;
  edited: () => Promise<Boolean>;
  video: <T = VideoPromise>() => T;
  user: <T = UserPromise>() => T;
  replies: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<CommentReview>>(args?: {
    where?: CommentReviewWhereInput;
    orderBy?: CommentReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  reply: () => Promise<AsyncIterator<Boolean>>;
  replyTo: <T = CommentSubscription>() => T;
  edited: () => Promise<AsyncIterator<Boolean>>;
  video: <T = VideoSubscription>() => T;
  user: <T = UserSubscription>() => T;
  replies: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = Promise<AsyncIterator<CommentReviewSubscription>>>(args?: {
    where?: CommentReviewWhereInput;
    orderBy?: CommentReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  text: String;
  reply: Boolean;
  edited?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  reply: () => Promise<Boolean>;
  edited: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  reply: () => Promise<AsyncIterator<Boolean>>;
  edited: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentReview {
  id: ID_Output;
  status?: ReviewStatus;
  createdAt: DateTimeOutput;
}

export interface CommentReviewPromise
  extends Promise<CommentReview>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ReviewStatus>;
  comment: <T = CommentPromise>() => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentReviewSubscription
  extends Promise<AsyncIterator<CommentReview>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ReviewStatus>>;
  comment: <T = CommentSubscription>() => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface CommentReviewSubscriptionPayload {
  mutation: MutationType;
  node: CommentReview;
  updatedFields: String[];
  previousValues: CommentReviewPreviousValues;
}

export interface CommentReviewSubscriptionPayloadPromise
  extends Promise<CommentReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentReviewPreviousValuesPromise>() => T;
}

export interface CommentReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentReviewPreviousValuesSubscription>() => T;
}

export interface PlaylistEdge {
  node: Playlist;
  cursor: String;
}

export interface PlaylistEdgePromise
  extends Promise<PlaylistEdge>,
    Fragmentable {
  node: <T = PlaylistPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaylistEdgeSubscription
  extends Promise<AsyncIterator<PlaylistEdge>>,
    Fragmentable {
  node: <T = PlaylistSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentReviewPreviousValues {
  id: ID_Output;
  status?: ReviewStatus;
  createdAt: DateTimeOutput;
}

export interface CommentReviewPreviousValuesPromise
  extends Promise<CommentReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ReviewStatus>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ReviewStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCommentReview {
  count: Int;
}

export interface AggregateCommentReviewPromise
  extends Promise<AggregateCommentReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentReviewSubscription
  extends Promise<AsyncIterator<AggregateCommentReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoPreviousValues {
  id: ID_Output;
  videoURL: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title: String;
  description?: String;
  tags: String[];
  isPublished: Boolean;
  isPublic: Boolean;
  category?: Category;
  allowComments?: Boolean;
  createdAt: DateTimeOutput;
}

export interface VideoPreviousValuesPromise
  extends Promise<VideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  videoURL: () => Promise<String>;
  thumbURL: () => Promise<String>;
  posterURL: () => Promise<String>;
  previewURL: () => Promise<String>;
  duration: () => Promise<Int>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  tags: () => Promise<String[]>;
  isPublished: () => Promise<Boolean>;
  isPublic: () => Promise<Boolean>;
  category: () => Promise<Category>;
  allowComments: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  videoURL: () => Promise<AsyncIterator<String>>;
  thumbURL: () => Promise<AsyncIterator<String>>;
  posterURL: () => Promise<AsyncIterator<String>>;
  previewURL: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  category: () => Promise<AsyncIterator<Category>>;
  allowComments: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentReviewConnection {
  pageInfo: PageInfo;
  edges: CommentReviewEdge[];
}

export interface CommentReviewConnectionPromise
  extends Promise<CommentReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentReviewEdge>>() => T;
  aggregate: <T = AggregateCommentReviewPromise>() => T;
}

export interface CommentReviewConnectionSubscription
  extends Promise<AsyncIterator<CommentReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentReviewSubscription>() => T;
}

export interface PlaylistSubscriptionPayload {
  mutation: MutationType;
  node: Playlist;
  updatedFields: String[];
  previousValues: PlaylistPreviousValues;
}

export interface PlaylistSubscriptionPayloadPromise
  extends Promise<PlaylistSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaylistPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaylistPreviousValuesPromise>() => T;
}

export interface PlaylistSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaylistSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaylistSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaylistPreviousValuesSubscription>() => T;
}

export interface AggregateVideo {
  count: Int;
}

export interface AggregateVideoPromise
  extends Promise<AggregateVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlaylistPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  isPublic?: Boolean;
  createdAt: DateTimeOutput;
}

export interface PlaylistPreviousValuesPromise
  extends Promise<PlaylistPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  isPublic: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistPreviousValuesSubscription
  extends Promise<AsyncIterator<PlaylistPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Video {
  id: ID_Output;
  videoURL: String;
  thumbURL?: String;
  posterURL?: String;
  previewURL?: String;
  duration?: Int;
  title: String;
  description?: String;
  tags: String[];
  isPublished: Boolean;
  isPublic: Boolean;
  category?: Category;
  allowComments?: Boolean;
  createdAt: DateTimeOutput;
}

export interface VideoPromise extends Promise<Video>, Fragmentable {
  id: () => Promise<ID_Output>;
  videoURL: () => Promise<String>;
  thumbURL: () => Promise<String>;
  posterURL: () => Promise<String>;
  previewURL: () => Promise<String>;
  duration: () => Promise<Int>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  tags: () => Promise<String[]>;
  isPublished: () => Promise<Boolean>;
  isPublic: () => Promise<Boolean>;
  category: () => Promise<Category>;
  views: <T = FragmentableArray<View>>(args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  allowComments: () => Promise<Boolean>;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<Video>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  videoURL: () => Promise<AsyncIterator<String>>;
  thumbURL: () => Promise<AsyncIterator<String>>;
  posterURL: () => Promise<AsyncIterator<String>>;
  previewURL: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  category: () => Promise<AsyncIterator<Category>>;
  views: <T = Promise<AsyncIterator<ViewSubscription>>>(args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  allowComments: () => Promise<AsyncIterator<Boolean>>;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface PlaylistConnection {
  pageInfo: PageInfo;
  edges: PlaylistEdge[];
}

export interface PlaylistConnectionPromise
  extends Promise<PlaylistConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaylistEdge>>() => T;
  aggregate: <T = AggregatePlaylistPromise>() => T;
}

export interface PlaylistConnectionSubscription
  extends Promise<AsyncIterator<PlaylistConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaylistEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaylistSubscription>() => T;
}

export interface ViewEdge {
  node: View;
  cursor: String;
}

export interface ViewEdgePromise extends Promise<ViewEdge>, Fragmentable {
  node: <T = ViewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ViewEdgeSubscription
  extends Promise<AsyncIterator<ViewEdge>>,
    Fragmentable {
  node: <T = ViewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  googleID: String;
  email: String;
  name: String;
  image: String;
  verified?: Boolean;
  googlePhotoAT?: String;
  googlePhotoRT?: String;
  role: Role;
  createdAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  googleID: () => Promise<String>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  verified: () => Promise<Boolean>;
  googlePhotoAT: () => Promise<String>;
  googlePhotoRT: () => Promise<String>;
  role: () => Promise<Role>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  googleID: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  googlePhotoAT: () => Promise<AsyncIterator<String>>;
  googlePhotoRT: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Review {
  id: ID_Output;
  status?: ReviewStatus;
  createdAt: DateTimeOutput;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ReviewStatus>;
  video: <T = VideoPromise>() => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ReviewStatus>>;
  video: <T = VideoSubscription>() => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewPreviousValues {
  id: ID_Output;
  status?: ReviewStatus;
  createdAt: DateTimeOutput;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ReviewStatus>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ReviewStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VideoConnection {
  pageInfo: PageInfo;
  edges: VideoEdge[];
}

export interface VideoConnectionPromise
  extends Promise<VideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoEdge>>() => T;
  aggregate: <T = AggregateVideoPromise>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface CommentReviewEdge {
  node: CommentReview;
  cursor: String;
}

export interface CommentReviewEdgePromise
  extends Promise<CommentReviewEdge>,
    Fragmentable {
  node: <T = CommentReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentReviewEdgeSubscription
  extends Promise<AsyncIterator<CommentReviewEdge>>,
    Fragmentable {
  node: <T = CommentReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlaylist {
  count: Int;
}

export interface AggregatePlaylistPromise
  extends Promise<AggregatePlaylist>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaylistSubscription
  extends Promise<AsyncIterator<AggregatePlaylist>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ViewSubscriptionPayload {
  mutation: MutationType;
  node: View;
  updatedFields: String[];
  previousValues: ViewPreviousValues;
}

export interface ViewSubscriptionPayloadPromise
  extends Promise<ViewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ViewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ViewPreviousValuesPromise>() => T;
}

export interface ViewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ViewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ViewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ViewPreviousValuesSubscription>() => T;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "CommentReview",
    embedded: false
  },
  {
    name: "Playlist",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  },
  {
    name: "ReviewStatus",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Video",
    embedded: false
  },
  {
    name: "View",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
